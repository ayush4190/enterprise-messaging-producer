const util = require('util');
const axios = require('axios');

const Logger = require('./helper/logging');
const { SettingsManager } = require('./settings_manager');
const { ParamCollection } = require('./params');

function addTokenInfo(params, authData) {
    params.set('token', authData.access_token);
    if (authData.expires_in) {
        params.set('tokenExpirationDate', Date.now() + authData.expires_in * 1000);
    } else {
        params.delete('tokenExpirationDate');
    }
    if (authData.refresh_token) {
        params.set('refreshToken', authData.refresh_token);
    } else {
        params.delete('refreshToken');
    }
}
function addUrlInfo(params, authData) {
    params.set('passcodeUrl', authData.passcode_url);
}
function getTokenUrl(params) {
    const tokenUrl = new URL(params.get('tokenUrl'));
    tokenUrl.search = `subdomain=${params.get('subdomain')}`;

    if (params.has('refreshToken')) {
        tokenUrl.search += `&refresh_token=${encodeURIComponent(params.get('refreshToken'))}`;
    } else if (params.has('passcode')) {
        tokenUrl.search += `&passcode=${encodeURIComponent(params.get('passcode'))}`;
    }
    if (params.has('clientid')) {
        tokenUrl.search += `&clientid=${encodeURIComponent(params.get('clientid'))}&clientsecret=${encodeURIComponent(params.get('clientsecret'))}`;
    }
    return tokenUrl.toString();
}

async function retrieveTokenOrPasscodeUrl(params) {
    if (params.has('token')) {
        if (params.get('renewLogin') || params.get('tokenExpirationDate') <= Date.now()) {
            Logger.debug((params.get('renewLogin') ? 'Renewing' : 'Refreshing expired') + ' authentication token');
            params.delete('token');
            params.delete('tokenExpirationDate');
        } else {
            return;
        }
    }
    if (!params.has('passcode') && !params.has('refreshToken') && params.has('passcodeUrl')) {
        return;
    }

    let retry;
    let authData;
    do {
        const tokenUrl = getTokenUrl(params);
        Logger.debug(`Getting authentication token or passcode URL from ${(params.obfuscateQueryParams(tokenUrl))}`);

        let response;
        try {
            response = await axios.get(tokenUrl);
        } catch (error) {
            throw new Error(`Failed to get authentication token: ${error}.\nResponse body: ${util.inspect(error.response && error.response.data)}`);
        }
        authData = response.data;

        retry = !authData.access_token && params.has('refreshToken') && (params.delete('refreshToken'), true);
    } while (retry);

    if (authData.access_token) {
        addTokenInfo(params, authData);
    } else {
        addUrlInfo(params, authData);
    }
}


module.exports = class AuthManager {

    static async loginAndUpdateSettings(paramValues) {
        SettingsManager.init();
        const params = new ParamCollection(paramValues);
        await SettingsManager.loadAndMergeSettings(params);
        if (params.has('username')) {
            params.set('reqAuth', { auth: { username: params.get('username'), password: params.get('password') } });
        } else {
            await retrieveTokenOrPasscodeUrl(params);
            if (!params.has('token')) {
                await SettingsManager.saveSettings(params);
                throw new Error('Failed to login: no valid token or passcode provided. ' +
                    'Get a passcode' + (params.get('passcodeUrl') ? ' from ' + params.get('passcodeUrl') : '') +
                    ' and supply the code when re-running the command');
            }
            params.set('reqAuth', { headers: { Authorization: 'Bearer ' + params.get('token') } });
        }

        await SettingsManager.saveSettings(params); // saves token conditionally

        return params;
    }

    static async logout(paramValues) {
        SettingsManager.init();
        const params = new ParamCollection(paramValues);
        if (params.get('clearInvalid')) {
            await SettingsManager.deleteInvalid();
        } else {
            await SettingsManager.deleteToken(params);
            if (params.get('deleteSettings')) {
                await SettingsManager.deleteSettingsWithoutToken(params);
            }
        }
    }

}
