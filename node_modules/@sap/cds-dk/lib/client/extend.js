const fs = require('fs');
const path = require('path');
const axios = require('axios');
const { fse } = require('@sap/cds-foss');

const AuthManager = require('./auth_manager');
const BaseCommand = require('./base_command');
const { normalizePath, isParent } = require('./helper/fs_helper');
const Logger = require('./helper/logging');
const Question = require('./helper/question');

const COMMAND_URL_SUFFIX = 'content';
const CUSTOM_FILE_FOLDERS = ['wsdl'];
const DB_FOLDER = 'db';
const SRV_FOLDER = 'srv';
const TEMPLATE_FOLDER = 'tpl';

function folderExists(folder) {
    return `${folder} already contains an extension project, use another directory or use --force.` +
        '\nWhen using --force, make sure you are using a version control system (like git) to avoid data loss';
}

module.exports = class Extend extends BaseCommand {

    static get COMMAND_URL_SUFFIX() { return COMMAND_URL_SUFFIX; }

    static async storeFiles(content, targetDirectory, filter) {
        fse.mkdirpSync(targetDirectory);
        targetDirectory = fs.realpathSync(targetDirectory)
        const writtenFiles = new Set();
        const filesToWrite = new Map();
        for (const [filename, filecontent] of content) {
            const filepath = path.join(targetDirectory, filename);
            if (filepath.startsWith(targetDirectory) && (!filter || await filter(filepath))) {
                filesToWrite.set(filepath, filecontent);
            }
        }
        for (const [filepath, content] of [...filesToWrite.entries()]) {
            const normalizedFilepath = normalizePath(filepath);
            fse.mkdirpSync(path.dirname(normalizedFilepath));
            fs.writeFileSync(normalizedFilepath, content);
            writtenFiles.add(path.relative(process.cwd(), normalizedFilepath));
            Extend._logWrittenFile(normalizedFilepath);
        }
        return writtenFiles;
    }

    static async storeCustomFiles(directory, customFiles) {
        const customFileMap = new Map();
        customFiles.forEach(entry => {
            if (entry.category === 'wsdl') {
                const normalizedFilename = normalizePath(entry.name);
                const folder = normalizedFilename.split(path.sep)[0];
                if (CUSTOM_FILE_FOLDERS.includes(folder)) {
                    customFileMap.set(entry.name, entry.content);
                }
            }
        });
        await Extend.storeFiles([...customFileMap], directory);
    }

    static async storeTemplateFiles(templates, directory) {
        await Extend.storeFiles(templates, directory, async filepath => {
            const normalizedPath = normalizePath(filepath);
            if (!isParent(path.join(directory, DB_FOLDER), normalizedPath) && !isParent(path.join(directory, SRV_FOLDER), normalizedPath)) {
                Logger.log(`Ignoring template ${normalizedPath}: not in ${DB_FOLDER} or ${SRV_FOLDER}`);
                return false;
            }
            return true;
        });
    }

    static async run(paramValues) {
        try {
            const params = await AuthManager.loginAndUpdateSettings(paramValues);

            if (process.env.DEBUG) {
                Logger.log(`\n\nCreating extension project with parameters ${JSON.stringify({
                    appUrl: params.get('appUrl'),
                    projectFolder: params.get('projectFolder'),
                    subdomain: params.get('subdomain'),
                    passcode: params.get('passcode'),
                    username: params.get('username'),
                    password: params.get('password') ? '***' : 'undefined'
                })}`);
            } else {
                Logger.log(`\n\nCreating extension project for ${params.get('appUrl')}, subdomain '${params.get('subdomain')}', in folder '${params.get('projectFolder')}'`);
            }

            const runOnExistingProject = await Extend.checkProject(params.get('projectFolder'));
            if (runOnExistingProject && !(params.get('force') || params.get('templates'))) {
                throw new Error(folderExists(params.get('projectFolder')));
            }

            try {
                await Extend.runExtend(params);
            } catch (error) {
                await Extend.handleHttpError(error, params);
            }
        } catch (mainError) {
            Logger.error(undefined, mainError);
        }
    }

    static async runExtend(params) {
        const contentUrl = Extend.getMtxApiUrl(params.get('appUrl'), COMMAND_URL_SUFFIX);
        const requestOptions = Object.assign({ retry: 0 }, params.get('reqAuth'));

        Logger.log('Retrieving files...');

        const [ response ] = (await axios.get(contentUrl, requestOptions)).data;

        Logger.log('\nWriting files to: ' + params.get('projectFolder'));

        if (params.get('templates')) {
            await Extend.storeTemplateFilesToTpl(response.templates, params.get('projectFolder'));
            return; // only write templates
        }

        const content = response.base.concat(response.extension);

        await Extend.storeFiles(content, params.get('projectFolder'));

        await fse.mkdirp(path.join(params.get('projectFolder'), DB_FOLDER));
        await fse.mkdirp(path.join(params.get('projectFolder'), SRV_FOLDER));

        Logger.log(`\nPut database extension models into ${DB_FOLDER} folder.`);
        Logger.log(`Put service extension models into ${SRV_FOLDER} folder.`);

        if (response.templates && response.templates.length > 0) {
            // only write templates if there are no extensions so far
            if (response.extension && response.extension.length === 0) {
                Logger.log(`Writing template files to ${DB_FOLDER} and ${SRV_FOLDER} folder`);
                await Extend.storeTemplateFiles(response.templates, params.get('projectFolder'));
            } else {
                Logger.log('Ignoring templates because extension is already active.');
            }
        }

        if (params.get('wsdl')) {
            Logger.log('Writing custom files');
            const customFileUrl = Extend.getMtxApiUrl(params.get('appUrl'), Extend.CUSTOM_FILE_URL_SUFFIX);
            const customFiles = (await axios.get(customFileUrl, requestOptions)).data;
            await Extend.storeCustomFiles(params.get('projectFolder'), customFiles);
        }
    }

    static async storeTemplateFilesToTpl(templates, projectFolder) {
        if (templates && templates.length > 0) {
            const targetDirectory = path.join(projectFolder, TEMPLATE_FOLDER);
            const targetExists = await fse.pathExists(targetDirectory);
            if (!targetExists || await this.promptTemplateOverwrite()) {
                if (targetExists) {
                    await fse.remove(targetDirectory);
                }
                Logger.log(`Writing template files to ${TEMPLATE_FOLDER} folder`);
                await Extend.storeTemplateFiles(templates, targetDirectory);
            }

        } else {
            Logger.log('No templates available');
        }
    }

    static promptTemplateOverwrite() {
        return Question.askBooleanQuestion(`This  will overwrite extisting templates in folder ${TEMPLATE_FOLDER}. Continue (yN)? `);
    }

    static _logWrittenFile(file) {
        Logger.log('CREATE: ' + file);
    }

}
