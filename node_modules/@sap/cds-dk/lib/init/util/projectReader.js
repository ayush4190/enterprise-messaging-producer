const path = require('path')
const { nullLogger } = require('../util/logger')
const { BuildTaskFactory } = require('@sap/cds/bin/build')
const { fs } = require('@sap/cds/lib/utils')
const P_LANGUAGE_JAVA = 'java'
const P_LANGUAGE_NODEJS = 'nodejs'
const DEFAULT_P_LANGUAGE = P_LANGUAGE_NODEJS
const BUILD_TASK_JAVA = "java-cf"
const BUILD_TASK_NODE = "node-cf"
const BUILD_TASK_HANA = "hana"
const BUILD_TASK_FIORI = "fiori"
const BUILD_TASK_MTX = "mtx"

module.exports = class ProjectReader {

    constructor(template) {
        this.template = template
    }

    /**
     * Returns cds.env using 'production' profile by default as mta deployment is executed with having production profile set.
     */
    async getEnv(profile = 'production') {
        const cdsEnvVar = process.env.CDS_ENV
        process.env.CDS_ENV = profile
        try {
            return await this.template.getEnv();
        } finally {
            cdsEnvVar ? process.env.CDS_ENV = cdsEnvVar : delete process.env.CDS_ENV
        }
    }

    get fsUtil() {
        return this.template.fsUtil
    }

    get logger() {
        return this.template.logger
    }

    get projectPath() {
        return this.template.projectPath
    }

    async read(options) {
        const env = await this.getEnv();
        this.logger.isDebug && this.logger.debug(JSON.stringify(env, null, 1))

        const capDescriptor = await this._getCapDescriptor(env, options)
        const uiDescriptor = await this._getUiDescriptor(env)
        const projectDescriptor = {
            cap: capDescriptor,
            ui: uiDescriptor
        }

        await this._validate(projectDescriptor)

        this.logger.isDebug && this.logger.debug(JSON.stringify(projectDescriptor, null, 1))
        return projectDescriptor
    }

    async _getCapDescriptor(env, options) {
        let capDescriptor = {
            for: options && options.for,
            pLanguage: DEFAULT_P_LANGUAGE,
            srv: {},
            db: [],
            requires: [],
            get isMultitenant() {
                return options && options.add && options.add.has('mtx') ||
                    env.requires.multitenancy ||
                    env.requires.db && env.requires.db.multiTenant ||
                    this.isJava && fs.existsSync('mtx-sidecar') ||
                    false
            },
            get isNodejs() {
                return this.pLanguage === P_LANGUAGE_NODEJS
            },
            get isJava() {
                return this.pLanguage === P_LANGUAGE_JAVA
            },
            get hasRequires() {
                return this.requires.length > 0
            },
            get hasRequiresDb() {
                return this.db.length > 0
            },
            get hasHana() {
                return this.requires.some(({resource}) => resource.isHana)
            },
            get hasXsuaa() {
                return this.requires.some(({resource}) => resource.isXsuaa)
            },
            get needsSidecar() {
                return (options && options.add.has('hana') || this.db.length > 0) && (this.isJava || !this.isMultitenant)
            },
            get hasApprouter() {
                return !!env.requires.approuter
            }
        }

        // setting the effective env as it might have changed by already executed 'add' commands, e.g. cds init foo --add hana,mta
        const cds = require('@sap/cds/lib')
        cds.env = env;

        const buildTasks = await new BuildTaskFactory(this.logger.isDebug ? this.logger : nullLogger, cds).getTasks({ root: this.projectPath, resolve: true, mta: false })

        await Promise.all(buildTasks.map(async (task) => {
            const relDestPath = ProjectReader._slash(path.relative(this.projectPath, task.dest))

            switch (task.for) {
                case BUILD_TASK_HANA:
                    // check whether we have a hana service binding defined as a hana build task is returned by default for compatibility reasons if neither hana, nor sqlite has been defined
                    if (this._hasHanaServiceBinding(env)) {
                        capDescriptor.db.push({ path: relDestPath, name: path.basename(task.src) })
                    }
                    break

                case BUILD_TASK_JAVA:
                    capDescriptor.pLanguage = P_LANGUAGE_JAVA
                    capDescriptor.srv = {
                        path: relDestPath,
                        name: path.basename(task.src),
                        ext: await this._getJavaExtDescriptor(task)
                    }
                    break

                case BUILD_TASK_NODE:
                    capDescriptor.srv = {
                        path: relDestPath,
                        name: path.basename(task.src)
                    }
                    break

                case BUILD_TASK_FIORI:
                case BUILD_TASK_MTX:
                    break

                default:
                    this.logger.warn(`Unknown build task type ${task.for}`)
            }
        }))

        // setting app name, app description...
        await this._setAppDetails(capDescriptor)

        // setting required resource information
        this._setResourceDependencies(env, capDescriptor)

        return capDescriptor
    }

    /**
     * Determines java specific properties for the given build task.
     * @param {object} task
     */
    async _getJavaExtDescriptor(task) {
        let descriptor = null
        // by default spring-boot:repackage is used creating an executable jar archive
        const pomJson = await this._parseXml(path.join(task.src, 'pom.xml'))
        if (pomJson) {
            if (this.template.name === "manifest" && this._isOldJavaRuntime(pomJson)) {
                throw new Error("Projects using the classic CAP Java SDK are not supported")
            }

            descriptor = {
                archiveName: path.basename(this.projectPath) + "-exec.jar"
            }
            const archiveName = ProjectReader._getProperty(pomJson, 'project.artifactId.0')
            if (archiveName) {
                if (ProjectReader._getProperty(pomJson, 'project.packaging.0') === 'war') {
                    descriptor.archiveName = archiveName + '-exec.war'
                } else {
                    descriptor.archiveName = archiveName + '-exec.jar'
                }
            }
        }
        return descriptor
    }

    async _getUiDescriptor(env) {
        const uiDescriptor = {
            appPath: null
        }

        const absoluteAppPath = path.join(this.projectPath, env.folders.app)
        if (await this.fsUtil.pathExists(absoluteAppPath)) {
            uiDescriptor.appPath = env.folders.app
        }

        return uiDescriptor
    }

    async _setAppDetails(capDescriptor) {
        if (capDescriptor.pLanguage !== P_LANGUAGE_JAVA && capDescriptor.pLanguage !== P_LANGUAGE_NODEJS) {
            throw Error(`${capDescriptor.pLanguage} not supported`)
        }

        // TODO - shall we use project related data from existing mta like version, name, id or description
        // and overwrite everything else?
        //
        // const mtaFile = path.join(this.projectPath, 'mta.yaml')
        // let mta
        // if (await this.fsUtil.pathExists(mtaFile)) {
        //     try {
        //         const {yaml} = require('@sap/cds-foss')
        //         const content = await this.fsUtil.readFile(mtaFile, 'utf-8')
        //         mta = yaml.parse(content)
        //     } catch (e) {
        //         this.logger.error(`Failed to load ${mtaFile} - skip mta data`)
        //         this.logger.error(e)
        //     }
        // }

        // if (mta) {
        //     details.id = mta.ID
        //     details.description = mta.description
        //     details.version = mta.version
        //     if (mta.ID) {
        //         details.name = mta.ID.replace('.', '-')
        //     }
        // }

        // 1.1. java - use parent pom.xml
        if (capDescriptor.pLanguage === P_LANGUAGE_JAVA) {
            const pomXmlPath = path.join(this.projectPath, 'pom.xml')
            try {
                if (await this.fsUtil.pathExists(pomXmlPath)) {
                    const pomJson = await this._parseXml(pomXmlPath)
                    const artifactId = ProjectReader._getProperty(pomJson, 'project.artifactId.0')
                    const description = ProjectReader._getProperty(pomJson, 'project.description.0')
                    let version = ProjectReader._getProperty(pomJson, 'project.version.0')
                    // might need to resolve <version>${revision}</version> property
                    const versionMatch = version.match(/\${1}\{{1}([\w-\\.]+)\}{1}/)
                    if (versionMatch && versionMatch.length === 2) {
                        const resolved = ProjectReader._getProperty(pomJson, 'project.properties.0.' + versionMatch[1] + '.0')
                        if (resolved) {
                            version = resolved
                        }
                    }
                    if (version) {
                        // check compliance with mta version format - copied from mbt build error message
                        // if not compliant we use a static default value, see below...
                        if (/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\+[0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*)?$/.test(version)) {
                            capDescriptor.appVersion = version
                        }
                    }
                    if (artifactId) {
                        const nameMatch = artifactId.match(/([\w-\\.]+)(-parent)+/)
                        if (Array.isArray(nameMatch)) {
                            capDescriptor.appName = nameMatch.length === 3 ? nameMatch[1] : artifactId
                        }
                    }
                    if (description) {
                        capDescriptor.appDescription = description
                    }
                }
            } catch (e) {
                this.logger.error(`Failed to read file ${pomXmlPath} - skip pom.xml data`)
                this.logger.error(e)
            }
        }

        // 1.2. use package.json
        if (!capDescriptor.appName) {
            const packageJsonPath = path.join(this.projectPath, 'package.json')
            if (await this.fsUtil.pathExists(packageJsonPath)) {
                try {
                    const packageJson = await this.fsUtil.readJSON(packageJsonPath, 'utf-8')
                    if (!capDescriptor.appDescription && packageJson.description) {
                        capDescriptor.appDescription = packageJson.description
                    }
                    if (!capDescriptor.appVersion && packageJson.version) {
                        capDescriptor.appVersion = packageJson.version
                    }
                    if (packageJson.name) {
                        let segments = packageJson.name.trim().split('/')
                        // scope as namespace
                        if (segments[0].startsWith('@')) {
                            segments[0] = segments[0].replace('@', '')
                        }
                        segments = segments.map(segment => segment.startsWith('@') ? encodeURIComponent(segment.replace('@', '')) : encodeURIComponent(segment))
                        if (!capDescriptor.appName) {
                            capDescriptor.appName = segments[segments.length - 1]
                        }
                        if (!capDescriptor.appId) {
                            capDescriptor.appId = segments.join('.')
                        }
                        if (!capDescriptor.appDescription) {
                            capDescriptor.appDescription = segments[segments.length - 1]
                        }
                    }
                } catch (e) {
                    this.logger.error(`Failed to read file ${packageJsonPath} - skip application data`)
                    this.logger.error(e)
                }
            }
        }

        // 2. use project name and static default values
        if (!capDescriptor.appName) {
            const projectName = path.basename(this.projectPath)
            capDescriptor.appName = projectName
        }
        if (!capDescriptor.appDescription) {
            capDescriptor.appDescription = capDescriptor.appName + " application"
        }
        if (!capDescriptor.appId) {
            capDescriptor.appId = capDescriptor.appName
        }
        if (!capDescriptor.appVersion) {
            capDescriptor.appVersion = '1.0.0'
        }
    }

    _setResourceDependencies(env, capDescriptor) {
        const hanaResources = new Map()
        const otherResources = new Map()

        for (const key of Object.keys(env.requires)) {
            // ignore abstract helper definitions like sql
            if (key === 'sql' || key === 'sqlite' || key === 'hana') continue
            const { kind } = env.requires[key]
            if (kind === 'hana' || kind === 'hana-mt' || kind === 'hana-cloud') {
                hanaResources.set(key, env.requires[key])
            } else {
                otherResources.set(key, env.requires[key])
            }
        }

        for (const [key, value] of hanaResources) {
            const resource = this._getReqResource(key, value, capDescriptor)
            if (resource) {
                // using production profile
                capDescriptor.requires.push({ resource })
            }
        }
        // add after hana resource dependencies have been handled as multitenant information is required
        for (const [key, value] of otherResources) {
            const resource = this._getReqResource(key, value, capDescriptor)
            if (resource) {
                // using production profile
                capDescriptor.requires.push({ resource })
            }
        }
    }

    _hasHanaServiceBinding(env) {
        const kind = ProjectReader._getProperty(env, 'requires.db.kind')
        return kind === 'hana' || kind === 'sql' && (
            ProjectReader._getProperty(env, 'requires.db.dialect') === 'hana' ||
            ProjectReader._getProperty(env, 'requires.db.use') === 'hana'
        )
    }

    _getReqResource(key, reqEntry, capDescriptor) {
        const resource = {
            name: ProjectReader._getResourceName(key, capDescriptor),
            service: '',
            get isMultitenant() {
                return capDescriptor.isMultitenant || reqEntry.multiTenant || false
            },
            vcap: reqEntry.vcap || {},
            get isManagedHana() {
                return this.service === 'service-manager' || this.vcap.label === 'service-manager'
            },
            get isPlainHana() {
                return this.service === 'hana' && !this.isManagedHana
            },
            get isHana() {
                return this.isPlainHana || this.isManagedHana
            },
            get isXsuaa() {
                return this.service === 'xsuaa'
            },
        }

        switch (reqEntry.kind) {
            case 'sql':
            case 'hana':
                if (reqEntry.kind === 'sql' && reqEntry.dialect !== 'hana' && reqEntry.use !== 'hana') {
                    break
                }
                // use different service name to avoid conflicts when switching from single tenant to multitenant
                // otherwise we would enforce that users have to delete the db container first
                if (resource.isMultitenant) {
                    //resource.name += '-mt'
                    resource.service = 'service-manager'
                    resource.vcap.plan = 'container'
                } else {
                    resource.service = 'hana'
                    resource.vcap.plan = 'hdi-shared'
                }
                break

            case 'xsuaa':
                // if (capDescriptor.isMultitenant) {
                //     resource.name += '-mt'
                // }
                resource.service = reqEntry.kind
                resource.vcap.plan = 'application'
                break

            default: {
                if (ProjectReader._getProperty(reqEntry, 'vcap.plan')) {
                    resource.service = reqEntry.kind
                } else {
                    this.logger.debug(`Skip resource ${key}`)
                }
            }
        }
        return resource.service ? resource : null
    }

    /**
     * Parse a given string containing xml
     * used to remove the _text object from converted json i.e. from xml-js.
     * example : converted json has "groupId":[{"_text":["customer"]}]
     * and after removing textAttributes (using this function): "groupId":["customer"]
     * @param xml string to parse
     * @returns parsed json object
     */
    async _parseXml(pomXmlPath) {
        const xmljs = require('xml-js');
        let xmljsParse = {};
        try {
            const xml = await this.fsUtil.readFile(pomXmlPath, 'utf-8')
            xmljsParse.project = JSON.parse(await xmljs.xml2json(xml, {
                ignoreComment: true,
                compact: true,
                alwaysArray: true,
                ignoreDeclaration: true,
                attributesKey: "$",
                trim: true,
                nativeType: true,
                ignoreInstruction: true,
                ignoreCdata: true,
                ignoreDoctype: true,
                textFn: this.removeTextAttributes
            })).project[0];
            return xmljsParse;
        } catch (e) {
            this.logger.error(`Failed to read file ${pomXmlPath} - skip pom.xml data`)
            this.logger.error(e)
        }
    }

    /*
        Remove the _text attributes and convert value it into array
        input : "groupId":[{"_text":["customer"]}]
        output: "groupId":["customer"]
    */
    removeTextAttributes(value, parentElement) {
        const parentElementsObj = Object.keys(parentElement._parent);
        const key = parentElementsObj.length;
        const keyName = parentElementsObj[key - 1];
        const arrKey = parentElement._parent[keyName];
        const arrKeyLen = arrKey.length;
        if (arrKeyLen > 0) {
            const arr = arrKey;
            const arrIndex = arrKey.length - 1;
            arr[arrIndex] = value;
        } else {
            parentElement._parent[keyName] = value;
        }
    }
    async _validate(projectDescriptor) {
        const capDescriptor = projectDescriptor.cap
        if (capDescriptor.db.length > 0) {
            if (capDescriptor.isJava) {
                //ensure package.json exists in db module
                await Promise.all(capDescriptor.db.map(async db => {
                    const dbPath = path.join(this.projectPath, db.path, "package.json")
                    if (!await this.fsUtil.pathExists(dbPath)) {
                        this.logger.error(`Missing package.json file in folder ${db.path} - 'cds add hana' will add the configuration for SAP HANA deployment`) //NOSONAR
                    }
                }))
            }
        } else {
            //this.logger.warn(`No SAP HANA service binding defined in the requires section of the project's package.json. Database module omitted`) //NOSONAR
        }
    }

    _isOldJavaRuntime(pomJson) {
        const dependencies = ProjectReader._getProperty(pomJson, "project.dependencies.0.dependency")
        if (Array.isArray(dependencies)) {
            return dependencies.some((dependency) => {
                const groupId = ProjectReader._getProperty(dependency, 'groupId.0')
                return /com\.sap\.cloud\.servicesdk/.test(groupId)
            })
        }
        return false
    }

    static _slash(filename) {
        return filename ? filename.replace(/\\/g, '/') : filename
    }

    static _getResourceName(key, capDescriptor) {
        let name = key
        // only if not already present
        if (!name.includes(capDescriptor.appName)) {
            name = capDescriptor.appName + '-' + name
        }
        return name
    }

    static _getProperty(src, segments) {
        segments = Array.isArray(segments) ? segments : segments.split('.')
        return segments.reduce((p, n) => p && p[n], src)
    }
}
