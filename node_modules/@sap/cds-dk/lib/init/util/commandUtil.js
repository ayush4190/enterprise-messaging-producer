const cp = require('child_process');
const os = require('os');

const { IS_WIN } = require('../constants');

const { nullLogger } = require('./logger');

class CommandUtil {

    /**
     * Execute a command and show output in console
     * spawn has problems with promisify so use native approach w/ Promise
     * @param cmd command
     * @param args command args
     * @param options spawn options
     * @param logger logger to use
     * @param collectResult if true, return complete console output as promise resolve value
     *                      this might result in a huge string!
     *
     * @returns Promise
     */
    async spawnCommand(cmd, args, options = {}, logger = nullLogger, collectResult = false) {
        args = this._sanitizeArgs(args);
        return new Promise((resolve, reject) => {
            logger.debug(`[spawn] ${cmd} ${args.join(' ')}`);

            options.env = options.env || process.env;

            const child = this._getChildProcess(cmd, args, options);

            // use inplace methods to ensure logger is called in context
            const stdLogBuffer = new LogBuffer((chunk) => logger.log(chunk), collectResult);
            child.stdout.on('data', (chunk) => {
                stdLogBuffer.handleChunk(chunk);
            });

            // use inplace methods to ensure logger is called in context
            // collect error log in case of Win to handle command not found (ENOENT),
            const errLogBuffer = new LogBuffer((chunk) => logger.error(chunk), (IS_WIN || collectResult));
            child.stderr.on('data', (chunk) => {
                errLogBuffer.handleChunk(chunk);
            });

            child.on('close', (code) => {
                // dump buffer
                stdLogBuffer.flush();
                errLogBuffer.flush();

                if (code === 0) {
                    resolve(stdLogBuffer.getResult());
                } else {
                    const errorLog = errLogBuffer.getResult();

                    const error = new Error(`${cmd} ${args.join(' ')} failed with code ${code}, ${errorLog}`)
                    // add code ENOENT on Win if command not found
                    if (IS_WIN && errorLog.includes(cmd) && /not recognized/i.exec(errorLog)) {
                        error.code = 'ENOENT';
                        error.path = cmd;
                    }

                    error.errLog = errorLog;
                    error.stdLog = stdLogBuffer.getResult();

                    reject(error);
                }
            });

            child.on('error', (err) => {
                reject(err);
            });
        });
    }

    _getChildProcess(cmd, args, options) {
        if (!IS_WIN) {
            return cp.spawn(cmd, args, options);
        }

        // always use cmd shell on Win since Win does not report ENOENT
        // we need to parse output which might differ from PS to cmd shell
        return cp.spawn('cmd', ['/s', '/c', cmd, ...args], {
            shell: true, // for windows only
            ...options
        });
    }

    _sanitizeArgs(args) {
        const result = [];
        for (const arg of args) {
            result.push(arg.replace(/[&;|]/g, ''));
        }
        return result;
    }

}

class LogBuffer {

    constructor(logMethod, collectResult) {
        this.logMethod = logMethod;
        this.collectResult = collectResult;
        this.result = '';
        this.buffer = '';
    }

    handleChunk(chunk) {
        const chunkStr = chunk.toString();

        if (this.collectResult) {
            this.result = this.result + chunkStr;
        }

        const seq = chunkStr.split(os.EOL);
        this.buffer = this.buffer + seq.shift();
        for (const line of seq) {
            this.flush();
            this.buffer = line;
        }
    }

    flush() {
        if (this.logMethod && this.buffer) {
            this.logMethod(this.buffer);
            this.buffer = '';
        }
    }

    getResult() {
        return this.result.trim();
    }
}

module.exports = new CommandUtil();
