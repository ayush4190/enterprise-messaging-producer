const os = require("os");
const path = require("path");
const cp = require("child_process");
const TemplateBase = require("../templateBase");
const term = require("../../../util/term");
const checks = require("../../../lint/checks");
const io = require("../../../lint/io");
const readline = require("readline");

const { OPTION_LINT_DEV, OPTION_LINT_GLOBAL } = require("../../constants");
const { mkdirp, fs } = require("@sap/cds/lib/utils");
const { getConfigPath, getFileExtensions } = require("@sap/eslint-plugin-cds/lib/api");
const generators = require("../../../lint/generators");

const IS_WIN = os.platform() === "win32";
const ALLOWED_FILE_EXTENSIONS = getFileExtensions();
const VSCODE_FILE_ASSOCIATIONS = {
  "csv": [ "csv", "csv (semicolon)", "tsv", "tab" ]
}

module.exports = class LintTemplate extends TemplateBase {
  constructor(projectPath, generator) {
    super(projectPath, generator, __dirname);
    this.projectPath = projectPath;
    this.customPath = path.join(this.projectPath, ".eslint");
    this.docsPath = path.join(this.customPath, "docs");
    this.rulesPath = path.join(this.customPath, "rules");
    this.testsPath = path.join(this.customPath, "tests");
    this.lintType = "local";
    this.customRuleExample = false;
    this.missingNpmDependencies = { names: [], msgs: [] };
    this.isTest = false;
  }

  async checkEnabled() {
    if (this.options.lint) {
      // If custom rule example is requested, also trigger
      // "custom" rule type of setup
      if (this.options.lint.has(OPTION_LINT_DEV)) {
        this.customRuleExample = true;
      }
      if (this.options.lint.has(OPTION_LINT_GLOBAL)) {
        this.lintType = "global";
      }
    }
    return true;
  }

  async run() {
    // Require ESLint v>=7.0.0
    if (!this.isTest) {
      this._checkEslint();
    }

    // To enable custom lint rules ('lint' or 'lint:dev')
    if (this.lintType === "local") {
      // Require local ESLint plugin installation and corresponding config
      this._checkEslintPlugin();
      await this._addEslintPluginConfig();
      // Include custom lint sample rule and test ('lint:dev')
      if (this.customRuleExample) {
        // Generate custom lint rules dirs
        await this._generateEslintDirs();

        if (!fs.existsSync(".eslint/rules/no-entity-moo.js")) {
          await this._copyFromTemplate(".eslint/rules", this.rulesPath);
        }
        if (!fs.existsSync(".eslint/tests/no-entity-moo.test.js")) {
          await this._copyFromTemplate(".eslint/tests", this.testsPath);
        }
        // Generate custom lint rules docs
        await generators.genDocs(this.projectPath);
      }

      // Generate VS Code extension settings
      const extensions = ALLOWED_FILE_EXTENSIONS.map((ext) => {
        return path.extname(ext).replace('.', '');
      })
      extensions.forEach((ext) => {
        if (ext in VSCODE_FILE_ASSOCIATIONS) {
          VSCODE_FILE_ASSOCIATIONS[ext].forEach((assoc) => {
            extensions.push(assoc)
          })
        }
      });
      await io.sanitizeVscodeSettings(
        this.projectPath,
        path.join(this.projectPath, ".vscode/settings.json"),
        this.lintType,
        extensions,
        this.customRuleExample
      );
    }

  }

  async finalize() {
    if (this.lintType !== "global") {
      if (this.missingNpmDependencies["names"].length > 0) {
        const task = `npm install --save-dev ${this.missingNpmDependencies[
          "names"
        ].join(" ")}`;

        if (this.options.force) {
          this.logger.log(
            `\n\nAlmost done - installing ${this.missingNpmDependencies["names"].length} npm dependencies:\n${task}`
          );
          this._runTask(task);
        } else {
          this.logger.log(
            `\n\nAlmost done - ${term.warn(
              `you are missing ${this.missingNpmDependencies["names"].length} npm dependencies`
            )}:\n`
          );
          this.missingNpmDependencies["msgs"].forEach((msg, i) => {
            this.logger.log(`(${i + 1}) ${msg}`);
            if (i === this.missingNpmDependencies["msgs"].length - 1) {
              this.logger.log("\n");
            }
          });
          await this._promptInstallDependencies(task);
        }
      }
    }

  }

  _checkEslint() {
    const eslintCmd = checks.resolveEslint(this.projectPath, '');
    if (!eslintCmd) {
      this.missingNpmDependencies["names"].push("eslint");
      this.missingNpmDependencies["msgs"].push("ESLint v>=7.0.0");
    }
    return;
  }

  _checkEslintPlugin() {
    const eslintPluginLocal = checks.resolvePlugin(
      "@sap/eslint-plugin-cds",
      this.projectPath
    );
    // Require locally installed ESLint CDS plugin
    if (!eslintPluginLocal) {
      this.missingNpmDependencies["names"].push("@sap/eslint-plugin-cds");
      this.missingNpmDependencies["msgs"].push("ESLint plugin for CDS");
    }
    return;
  }

  async _generateEslintDirs() {
    await mkdirp(this.docsPath);
    await mkdirp(this.rulesPath);
    await mkdirp(this.testsPath);
    return;
  }

  async _copyFromTemplate(source, dest) {
    await this.templateUtil.copyFiles(source, dest, {}, true);
    return;
  }

  async _addEslintPluginConfig() {
    let configPath = getConfigPath(this.projectPath, this.logger);
    if (!configPath) {
      configPath = path.join(this.projectPath, ".eslintrc");
    }
    await io.sanitizeEslintConfig(configPath, this.customRuleExample, this.logger);
    return;
  }

  async _promptInstallDependencies(task) {
    if (!process.stdin.isTTY) {
      return; // non-interactive shell, like in tests
    }
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });
    // Do not install dependencies by default
    let received = "no";
    const timerID = setTimeout(() => {
      rl.write("no" + os.EOL);
    }, 10000);
    // Ask user whether dependences should be installed
    const question = `${term.warn("Install dependencies now")} ? [y/n] `;
    let todos = `${term.error(
      "Aborted!\nPlease install the following components manually:"
    )}\n\n${term.warn(task)}`;
    return new Promise((resolve, reject) => {
      rl.question(question, (answer) => {
        rl.close();
        clearTimeout(timerID);
        received = answer.trim().toLowerCase();
        // If user confirms or force flag is set, install dependencies
        if (["y", "yes"].includes(received) || this.options.force) {
          resolve(this._runTask(task));
          // If use declines or question timeout is reached, print todos
        } else if (["n", "no"].includes(received.toLowerCase())) {
          this.logger.log(todos);
          resolve();
        } else {
          // Close and restart question (with new timeout)
          rl.close();
          clearTimeout(timerID);
          this._promptInstallDependencies(task).then(resolve).catch(reject);
        }
      });
    })
  }

  _runTask(task) {
    let doneTask = true;
    try {
      cp.execSync(task, {
        cwd: this.projectPath,
        shell: IS_WIN,
        stdio: "inherit",
      });
    } catch (err) {
      doneTask = false;
    }
    return doneTask;
  }
};
