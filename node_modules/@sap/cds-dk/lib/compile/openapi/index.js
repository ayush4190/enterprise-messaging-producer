const csdl2openapi = require('./csdl2openapi');
const cds = require('@sap/cds');

module.exports = function processor(csn, options = {}) {

    // must not be part of function* otherwise thrown errors are swallowed
    const csdl = cds.compile.to.edm(csn, options);

    if (csdl[Symbol.iterator]) { // generator function means multiple services
        return _iterate(csdl, csn, options)
    } else {
        const openApiOptions = toOpenApiOptions(csdl, csn, options)
        return _getOpenApi(csdl, openApiOptions);
    }

    // const file = csdl.$EntityContainer.replace(/\.[^.]+$/, '');
    // yield [openapi, { file }]; // add file to avoid relative path in filename
    // return openapi;
}

function* _iterate(csdl, csn, options) {
    for (let [content, metadata] of csdl) {
        if (typeof content === 'string') {
            content = JSON.parse(content);
        }
        const openApiOptions = toOpenApiOptions(content, csn, options)
        const openapi = _getOpenApi(content, openApiOptions);
        yield [openapi, { file: metadata.file }];
    }
}

function _getOpenApi(csdl, options) {
    const openapi = csdl2openapi.csdl2openapi(csdl, options);
    csdl2openapi.deleteUnreferencedSchemas(openapi);
    return openapi;
}

function toOpenApiOptions(csdl, csn, options={}) {
    const result = {}
    for (const key in options) {
        if (/^openapi:(.*)/.test(key) && RegExp.$1)
            result[RegExp.$1] = options[key]
    }
    if (result.url) {
        result.url = result.url.replace(/\/*\$\{service-path\}/g, servicePath(csdl, csn))
    }
    else { // no 'url' option set: infer URL from service path
        result.url = servicePath(csdl, csn) // /catalog
    }
    return result
}

function servicePath(csdl, csn) {
    if (csdl.$EntityContainer) {
        const serviceName = csdl.$EntityContainer.replace(/\.[^.]+$/, '')
        const service = csn.definitions[serviceName]
        return cds.service.path4 ? cds.service.path4(service) : cds.serve.path4(service)
    }
}
