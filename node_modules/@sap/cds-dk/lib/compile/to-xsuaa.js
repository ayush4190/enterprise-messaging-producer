const cds = require ('@sap/cds')
const fs = require('fs')
const path = require('path')

const hardcoded = {
  Scopes: ['system-user', 'authenticated-user', 'registered-user', 'identified-user', 'internal-user', 'any'],
  Attributes: ['id', 'tenant', 'ext_attr']
}


module.exports = function compile_to_xsuaa (model, options) {

  const base = getBaseModel(options)
  const scopes = {}
  const attributes = {}

  const findUserAttrInExpression = (expr, attributes = []) => {
    if (Array.isArray(expr)) { // descend arrays
      expr.forEach(e => findUserAttrInExpression(e, attributes))
    }
    else if (typeof expr === 'object' && expr.ref) {
      const userIdx = expr.ref.indexOf('$user')
      if (userIdx >= 0 && userIdx < expr.ref.length - 1) {
        const attr = expr.ref[userIdx + 1]
        if (!hardcoded.Attributes.includes(attr)) attributes.push(attr)
      }
    }
    return attributes
  }

  const parseAttributes = (condition) => { // e.g. 'foo = $user.bar or baz = $user.boo'
    if (!condition) return []

    try {
      // {"xpr":[{"ref":["foo"]},"=",{"ref":["$user","bar"]},"or",{"ref":["baz"]},"=",{"ref":["$user","boo"]}]}
      const expr = cds.parse.expr(condition)
      // find paths value following $user, i.e. 'bar' and 'boo'
      return findUserAttrInExpression(expr.xpr)
    } catch (err) {
      throw new Error(`${err.message} in '${condition}'`)
    }
  }

  cds.reflect(model).foreach(def => {
    var reqAnnotations = def['@requires']
    if(!Array.isArray(reqAnnotations)) reqAnnotations=[reqAnnotations]

    reqAnnotations.forEach(scope => {
      if (scope && !hardcoded.Scopes.includes(scope)) {
        scopes[scope] = scope
      }
    })

    const annotationRes = def['@restrict']
    if (annotationRes) {
      annotationRes.forEach(restriction => {
        var restrTo = restriction.to
        if(!Array.isArray(restrTo)) restrTo=[restrTo]
        restrTo.forEach(scope =>{
          if (scope && !hardcoded.Scopes.includes(scope)) {
            scopes[scope] = scope
          }
        })
        const lattributes = parseAttributes(restriction.where)
        lattributes.forEach(attr => attributes[attr] = true)
      })
    }
  })
  var roleTemplates = Object.keys(scopes).map((s) => {
    return {
      name: s,
      description: 'generated',
      'scope-references': ['$XSAPPNAME.' + s],
      'attribute-references': []
    }
  });
  if (Object.keys(attributes).length !== 0) {
    roleTemplates.push({
      name: 'userattributes',
      description: 'generated',
      'default-role-name': 'Attributes of a User',
      'scope-references': [],
      'attribute-references': Object.keys(attributes)
    })
  }

  const generated = {
    scopes: Object.keys(scopes).map((s) => {
      return {
        name: '$XSAPPNAME.' + s,
        description: s
      }
    }),
    attributes: Object.keys(attributes).map((a) => {
      return {
        name: a,
        description: a,
        valueType: 's',
        valueRequired: false
      }
    }),
    'role-templates': roleTemplates
  }
  return mergeConfig(base, generated)
}


function mergeConfig(base, generated) {
  const result = base

  const mergeByName = (type) => {
    if (!generated[type]) return

    if (!result[type]) result[type] = []
    result[type] = result[type].concat(generated[type].filter((g) => {
      if (!base[type].find) throw new Error(`Array expected for '${type}', but was: ${JSON.stringify(base)}`)
      return !(base[type].find((b) => b.name === g.name))
    }))
  }
  mergeByName('scopes')
  mergeByName('attributes')
  mergeByName('role-templates')

  return result
}

function getBaseModel(options = {}) {
  if (typeof options.base === 'string') {
    try {
      return JSON.parse(options.base) // plain object
    } catch (err) {
      try {
        return JSON.parse(fs.readFileSync(path.resolve(options.base))); // file
      } catch (err2) {
        throw new Error('Neither a JSON object nor a file path: ' + options.base)
      }
    }
  }
  return options.base || {}
}
