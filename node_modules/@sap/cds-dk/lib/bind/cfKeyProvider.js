const cp = require('child_process');
const os = require('os');
const util = require('util');

const axios = require('axios');
const { URL } = require('url');

const execAsync = util.promisify(cp.exec);
const IS_WIN = os.platform() === 'win32';

class CFKeyProvider {

    constructor() {
        this.logger = console;
    }

    async _cfRead(...args) {
        this.logger.debug(`_cfRead: cf ${args}`);

        const result = await execAsync(`cf ${args}`, {
            shell: IS_WIN,
            stdio: ['inherit', 'pipe', 'inherit'],
        });

        return result.stdout.toString().trim();
    }

    async _req(target, urlPath) {
        const url = new URL(urlPath, target.apiEndpoint);

        this.logger.debug(`_req: ${url.toString()}`);

        const result = await axios.get(url.toString(), {
            headers: {
                authorization: target.authorization
            }
        });

        return result.data;
    }

    extract(string, pattern, errorMsg) {
        const match = string.match(pattern);
        if (!match || !match[1]) {
            throw new Error(errorMsg);
        }
        return match[1];
    }

    async getCfTargetFromCli() {
        const result = await this._cfRead('target');
        return {
            apiEndpoint: this.extract(result, /api endpoint\s*:\s*(.*)/i, `CF API endpoint is missing. Use 'cf login' to login.`),
            user: this.extract(result, /user\s*:\s*(.*)/i, `CF user is missing. Use 'cf login' to login.`),
            org: this.extract(result, /org\s*:\s*(.*)/i, `CF org is missing. Use 'cf target -o <ORG> to specify.`),
            space: this.extract(result, /space\s*:\s*(.*)/i, `CF space is missing. Use 'cf target -s <SPACE>' to specify.`),
        };
    }

    async getCfSpaceInfo() {
        this.logger.debug('getting space info');

        const target = await this.getCfTargetFromCli();
        const authorization = await this.getCfAuthorization();
        const targetWithAuth = Object.assign({}, target, { authorization });


        const { org, space } = target;
        const orgs = await this._req(targetWithAuth, `/v3/organizations?names=${org}`);
        if (!(orgs && orgs.resources.length === 1)) {
            throw new Error(`CF org ${org} not found!`);
        }

        const orgGuid = orgs.resources[0].guid;
        const spaces = await this._req(targetWithAuth, `/v3/spaces?names=${space}&organization_guids=${orgGuid}`)
        if (!(spaces && spaces.resources.length === 1)) {
            throw new Error(`CF space ${space} not found in org ${org}!`);
        }

        const spaceGuid = spaces.resources[0].guid;

        return Object.assign({}, target, { orgGuid, spaceGuid, authorization });
    }

    async getCfAuthorization() {
        this.logger.debug('getting authorization');
        return this._cfRead('oauth-token');
    }

    setLogger(logger) {
        this.logger = logger;
    }

    async init() {
        const target = this.target = await this.getCfSpaceInfo();
        const logger = this.logger;
        this.getOrg = BatchRequest.create({logger, target, url: '/v3/organizations'});
        this.getSpace = BatchRequest.create({logger, target, url: '/v3/spaces', extractors: {
            organization_guids: resource => resource.relationships.organization.data.guid
        }});
        this.getInstance = BatchRequest.create({logger, target, url: '/v3/service_instances', extractors: {
            space_guids: resource => resource.relationships.space.data.guid
        }});
        this.getKey = BatchRequest.create({logger, target, url: '/v3/service_credential_bindings', extractors: {
            service_instance_guids: resource => resource.relationships.service_instance.data.guid
        }});
        this.getPlans = BatchRequest.create({logger, target, url: '/v3/service_plans' });
        this.getOfferings = BatchRequest.create({logger, target, url: '/v3/service_offerings' });
    }

    async resolve(name, binding) {
        if (!this.initPromise) {
            this.initPromise = this.init();
        }
        await this.initPromise;

        const target = this.target;

        let {instance, key, apiEndpoint, org, space} = binding;
        key = key || `${instance}-key`;
        name = name || `${instance}:${key}`;

        if (apiEndpoint && apiEndpoint !== target.apiEndpoint) {
            throw new Error(`Current Cloud Foundry api endpoint "${target.apiEndpoint}" different than api endpoint "${apiEndpoint}" for service binding "${name}".`);
        }

        let spaceGuid;
        if (org && space) {
            const orgObj = await this.getOrg({ names: org });
            const spaceObj = await this.getSpace({ names: space, organization_guids: orgObj.guid });
            spaceGuid = spaceObj.guid;
        } else {
            org = target.org;
            space = target.space;
            spaceGuid = target.spaceGuid;
        }

        let instanceObj;
        try {
            instanceObj = await this.getInstance({ names: instance, space_guids: spaceGuid });
        } catch(error) {
            throw new Error(`Service instance "${instance}" not found.`);
        }
        let keyObj;
        try {
            keyObj = await this.getKey({names: key, service_instance_guids: instanceObj.guid });
        } catch(error) {
            throw new Error(`No service key "${key}" found for service instance "${instance}".`);
        }
        const planObj = await this.getPlans({guids: instanceObj.relationships.service_plan.data.guid});
        const offeringObj = await this.getOfferings({guids: planObj.relationships.service_offering.data.guid });
        const keyCredentialsObj = await req(this.logger, target, `/v3/service_credential_bindings/${encodeURIComponent(keyObj.guid)}/details`);
        const resolvedBinding = {
            binding: {
                type: "cf",
                apiEndpoint: target.apiEndpoint,
                org: org,
                space: space,
                instance: instance,
                key: key,
                vcap: {
                    label: offeringObj.name,
                    plan: planObj.name,
                    tags: offeringObj.tags
                },
                resolved: true,
            },
            credentials: keyCredentialsObj.credentials
        };

        return resolvedBinding;
    }
}

class BatchRequest {
    constructor({logger, target, url, extractors = {}}) {
        this.logger = logger;
        this.target = target;
        this.url = url;
        this.filters = [];
        this.timeout = undefined;
        this.extractors = Object.assign({ names: resource => resource.name, guids: resource => resource.guid }, extractors);
    }

    static create(options) {
        const obj = new BatchRequest(options);
        return (...args) => obj.request(...args);
    }

    async request(filter) {
        let resolve;
        let reject;
        const promise = new Promise( (_resolve, _reject) => {
            resolve = _resolve;
            reject  = _reject;
        });
        this.filters.push({ filter, resolve, reject });

        if (this.timeout) clearTimeout(this.timeout);
        this.timeout = setTimeout(() => this.executeRequest(), 0);

        return promise;
    }

    async executeRequest() {
        const filters = this.filters;
        this.filters = [];
        const filterParams = {};
        for (const filter of filters) {
            for (const name of Object.keys(filter.filter)) {
                if (!filterParams[name]) filterParams[name] = [];
                filterParams[name].push(filter.filter[name]);
            }
        }

        const params = Object.keys(filterParams).map(
            name => `${name}=${filterParams[name].map( value => encodeURIComponent(value) ).join(',')}`
        ).join("&");

        const url = this.url + (this.url.match(/\?/) ? '&' : '?') + params;

        let data;
        try {
            data = await this.httpRequest(url);
        } catch (error) {
            for (const filter of filters) {
                filter.reject(error);
            }
            return;
        }
        const fmt = filter => Object.keys(filter).map( key => `${key}: ${filter[key]}` ).join(', ');
        const resources = data.resources;
        for (const filter of filters) {
            let filteredResources = resources;
            for (const name of Object.keys(filter.filter)) {
                filteredResources = filteredResources.filter( resource => this.extractors[name](resource) === filter.filter[name] );
            }
            if (filteredResources.length === 1) {
                filter.resolve(filteredResources[0]);
            } else if (filteredResources.length === 0) {
                filter.reject(new Error(`Couldn't find resource for url "${this.url}" with filter "${fmt(filter.filter)}"`));
            } else {
                filter.reject(new Error(`Found more than one resources for url "${this.url}" with filter "${fmt(filter.filter)}"`));
            }
        }
    }

    async httpRequest(urlPath) {
        return req(this.logger, this.target, urlPath);
    }
}

async function req(logger, target, urlPath) {
    const url = new URL(urlPath, target.apiEndpoint);

    logger.debug(`_req: ${url.toString()}`);

    const result = await axios.get(url.toString(), {
        headers: {
            authorization: target.authorization
        }
    });

    return result.data;
}

module.exports = new CFKeyProvider();
