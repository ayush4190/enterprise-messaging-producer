
const os = require('os');
const IS_WIN = os.platform() === 'win32';

const KindToRequiresNameMap = {
    xsuaa: 'uaa',
    'xsuaa-auth': 'uaa',
    'hana-cloud': 'db',
    hana: 'db',
    destinations: 'destinations',
    connectivity: 'connectivity',
    'audit-log': 'audit-log',
    'enterprise-messaging': 'messaging',
    'enterprise-messaging-amqp': 'messaging',
    'enterprise-messaging-http': 'messaging',
    'enterprise-messaging-shared': 'messaging'
}

const PreferredKinds = [
    'hana-cloud',
    'xsuaa'
];

function getRequiresNameFromKind(service, kind) {
    const requiresName = KindToRequiresNameMap[kind];
    if (!requiresName) throw new Error(`Unknown CDS service name for service "${service}". Please specify as argument for "cds bind".`)
    return requiresName;
}

/**
 * Determine kind value for services based on VCAP binding
 * information in the configuration.
 */
function determineKinds(services) {
    const vcapServices = {}

    // Build VCAP_SERVICES
    for (const service of services) {
        service.kindCandidates = [ ]

        const { label, name, tags } = service.binding && service.binding.vcap || {};
        if (!label) continue;

        if (!vcapServices[label]) vcapServices[label] = [];
        vcapServices[label].push({ credentials: { dummy: 'dummy' }, label, name, tags, service });
    }

// Auto configure services based on VCAP_SERVICES

    const cds = require('@sap/cds/lib');
    const env = cds.env.for('cds', process.cwd());

    if (!env._find_credentials_for_required_service) {
        throwError `Please provide a service kind or update @sap/cds version to use the kind detection.`;
    }

    const requires = env.requires.kinds || {};
    for (const kind of Object.keys(requires)) {
        const requireService = requires[kind];
        const vcapService = env._find_credentials_for_required_service(kind, requireService, vcapServices);
        if (!vcapService) continue;
        if (!Object.values(requires).find( require => require !== requireService && require.kind == kind ))
            vcapService.service.kindCandidates.push(kind);
    }

    // Check if one "kind" per service was found
    for (const service of services) {
        const preferredKind = service.kindCandidates.find( kind => PreferredKinds.indexOf(kind) >= 0);
        if (preferredKind) {
            service.kind = preferredKind;
        } if (service.kindCandidates.length === 1) {
            service.kind = service.kindCandidates[0];
        }

        delete service.kindCandidates;
    }
}

function execAndExit(command, ...args) {
    const { spawnSync } = require('child_process');
    // use shell with Windows only; without output is not visible and some commands cannot be run
    const result = spawnSync(command, args, { stdio: 'inherit', shell: IS_WIN });
    process.exit(result.status);
}

async function checkIsJavaProject(projectPath) {
    const { constants, promises: fsp } = require('fs');
    const path = require('path');
    const pomXmlPath = path.join(projectPath, 'pom.xml');
    try {
        await fsp.access(pomXmlPath, constants.F_OK);
        return true;
    } catch (err) {
        return false;
    }
}


/**
 *
 * @param {string} msg
 * @returns {never}
 */
 function throwError(msg = 'Internal Error') {
    throw new Error(msg);
}


const PLATFORM_TYPES = {
    'cf': 'Cloud Foundry',
    'k8s': 'Kubernetes'
}

function platformText(binding) {
    return PLATFORM_TYPES[binding.type] || throwError(`Unexpected binding type "${binding.type}"`);
}

function bindingText(binding, highlight = t => t) {
    switch (binding.type) {
        case 'cf':
            return `service ${highlight(binding.instance)} key ${highlight(binding.key)}`
        case 'k8s':
            if (binding.name) {
                return `service binding ${highlight(binding.name)}`
            } else {
                return `secret ${highlight(binding.secret)}`
            }
        default:
            throwError();
    }
}

module.exports = {
    getRequiresNameFromKind,
    determineKinds,
    execAndExit,
    checkIsJavaProject,
    throwError,
    platformText,
    bindingText
}
