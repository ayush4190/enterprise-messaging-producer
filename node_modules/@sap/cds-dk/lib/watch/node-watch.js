const DEBUG = /\bwatch\b/.test(process.env.DEBUG) && console.debug

module.exports = ({ cwd, script, ext, ignore=RegExp(), env={}, delay=200, options={} })=>{

  let child

  // Phoning home...
  const EventEmitter = require('events')
  const emitter = new EventEmitter

  const killAndExit = (sig) => {
    DEBUG && DEBUG('Signal:', sig)
    emitter.emit('quit')
    _kill (child, () => process.exit())
  }
  process.on('SIGTERM', killAndExit)
  process.on('SIGINT', killAndExit)

  // Re-starting child process...
  const { fork } = require('child_process')
  const restart = _coalesceEvents(delay, (events) => {
    DEBUG && DEBUG('>> Events:', events)
    _kill (child, () => {
      const execArgv = [...process.execArgv]
      events.forEach(evt => {
        if (evt.type && evt.type.startsWith('--')) execArgv.push(evt.type)
        if (evt.name && evt.name.startsWith('--')) execArgv.push(evt.name)
      })
      if (options.debug) execArgv.push('--inspect')
      if (options['debug-brk']) execArgv.push('--inspect-brk')

      const updated = events.filter(evt => evt.type && evt.type === 'update').map(evt => evt.name)
      emitter.emit ('restart', updated)
      child = fork (script, { cwd, env, stdio:'inherit', execArgv }, (err)=>{
        if (err) console.error (err)
      })
      child.on('message', msg => {
        if (msg === 'restart') return restart()
        emitter.emit('message', msg)
      })
    })

  })

  restart()

  // Watching for touched files...
  const watch = require('node-watch')
  const include = RegExp(`\\.(${ext.replace(/,/g,'|')})$`)
  const filter = f => !ignore.test(f) && include.test(f)
  watch (process.cwd(),{ recursive:true, filter, delay:0 }, restart)

  // Live commands...
  const readline = require('readline')
  readline.createInterface(process.stdin).on('line', (input) => {
    if (input === '') restart()
    else if (input === 'restart' || input === 'rs' || input.match(/^y$/i)) restart()
    else if (input === 'debug' || input === 'dbg')  restart('--inspect')
    else if (input === 'break' || input === 'brk')  restart('--inspect-brk')
    else if (input === 'debug-brk')  restart('--inspect-brk')
    else if (input === 'ps') ps(child,env)
    else if (input === 'bye' || input.match(/^n$/i)) { _kill (child, () => process.exit())  }
    else console.log ('?\n')
  })

  emitter.restart = restart
  emitter.stop    = () => { _kill(child, () => false); child = undefined; }
  emitter.setEnv = (name, value) => {
    if (typeof value === "undefined") {
      delete env[name]
    } else {
      env[name]
    }
  }
  return emitter
}

const ps = (child,env) => console.log (`\x1b[32m
  PID     Process   Command
  ${process.pid}   parent    cds ${process.argv.slice(2).join(' ')}
  ${  child.pid}   child     cds ${JSON.parse(env._args).join(' ')}
  \x1b[0m`
)

// reduces mutiple node-watch events in a time frame into a bulk
function _coalesceEvents(delay, fn) {
  let timer, cache = []
  function handle() {
    fn(cache)
    timer = null
    cache = []
  }
  return function(type, name) { // node-watch callback signature
    cache.push({type, name})
    if (!timer) {
      timer = setTimeout(handle, delay);
    }
  }
}

function _kill (proc, fn=()=>{}) {
  if (!proc)  return fn()

  // On Windows, child_process.kill() abruptly kills the process (https://nodejs.org/api/child_process.html#subprocesskillsignal)
  // Server has cleanup code to run, so send a custom message and give it a bit time.
  if (process.platform === 'win32') {
    proc.send({ exit: true }, () => {})
    const waitTime = parseInt(process.env.CDS_WATCH_KILL_DELAY) || 500
    setTimeout(()=> { proc.kill(); fn() }, waitTime)
  } else {
    proc.kill(); fn()
  }
}
