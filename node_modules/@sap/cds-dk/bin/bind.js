module.exports = Object.assign(cds_bind, {
    options: ['--to', '--on', '--profile', '--kind', '--output-file'],
    flags: ['--exec'],
    shortcuts: ['-2', '-n', '-p', '-k', '-o'],
    help: `
# SYNOPSIS

    *cds bind* <service> [<options>]
    *cds bind --exec* [--profile <profile>] [--] <command> <args ...>

    Binds the given service to a service instance by storing connection information in *.cdsrc-private.json*
    in your project directory. Credentials are not stored in the file but rather retrieved dynamically during *cds watch*.
    Use option *--output-file* to specify a different path or file.

    With *--exec* you can execute arbitrary commands with your service bindings. The service bindings are provided
    in the *VCAP_SERVICES* env variable to the command.

# OPTIONS

    *-2 | --to* <instance>[:<key>] | <service-binding> | <secret>
        bind to a given Cloud Foundry instance, Kubernetes service binding or Kubernetes secret.

    *-n | --on* cf | k8s
        bind to service on Cloud Foundry or Kubernetes, defaults to Cloud Foundry

    *-p | --profile* <profile>
        add the given profile, defaults to *hybrid*

    *-k | --kind* <kind>
        the kind of service

    *-o | --output-file* <path>
        save bindings to the given *.cdsrc.json* or *package.json* file. Default is *.cdsrc-private.json*.
        If *path* is a directory, then it will save it to the *.cdsrc.json* file in that directory.

# EXAMPLE

    cds bind --to my-hdi-container
    cds bind --to my-hdi-container,my-xsuaa
    cds bind uaa --to my-xsuaa:my-xsuaa-key --kind xsuaa --profile myprofile

    cds bind --to my-hdi-container --output-file .
    cds bind --to my-hdi-container --output-file package.json

    cds bind --to my-hdi-container --on k8s
`
});

const cds = require('@sap/cds/lib');
const LOG = cds.log('bind');
// required for spinner
LOG.isDebug = LOG._debug;
LOG.isTTY = process.stdout.isTTY;

const { highlight, bold, info } = require('../lib/util/term');

const Spinner = require('../lib/init/util/spinner');
const resolveBinding = require('../lib/bind/bindingResolver').resolver(LOG);
const { determineKinds, getRequiresNameFromKind, execAndExit, checkIsJavaProject, throwError, platformText, bindingText } = require('../lib/bind/bindingUtil');

const VCAP_LABEL_PLACEHOLDER = '<replace with service label>';

async function cds_bind(args, options, logger = LOG) {
    options.profile = parseProfile(options.profile);
    setProfile(options.profile);

    if (options.exec) {
        cds_bind_exec(args, options)
        return;
    }

    const env = cds.env.for('cds', process.cwd());

    if (!options.to) {
        throw new Error(`use option --to or -2 to specify the target instance, e.g. cds bind --to myInstance:myService`);
    }

    if (args.length > 1) {
        throw new Error(`Too many arguments: Please specify only one or no service.`);
    }

    const isJavaProject = await checkIsJavaProject(process.cwd());

    let serviceArg = args[0]
    const targets = options.to.split(/,/g);

    if (targets.length >= 2 && serviceArg) {
        throw new Error(`Service argument cannot be specified together with multiple targets ('--to') services. Use one service per call or omit the service argument.`);
    }

    if (targets.length >= 2 && options.kind) {
        throw new Error(`The option '--kind' cannot be specified together with multiple targets ('--to') services. Use one service per call or omit the '--kind' option.`);
    }

    const spinner = new Spinner(logger);

    let on;
    if (options.on === 'k8s' || options.on === 'kubernetes') {
        on = 'k8s';
    } else if (!options.on || options.on === 'cf' || options.on === 'cloudfoundry') {
        on = 'cf';
    } else {
        throw new Error(`Invalid value '${options.on}' for option --on.`);
    }

    const onText = { 'cf': 'Cloud Foundry', 'k8s': 'Kubernetes' }[on];
    const resolvedServices = await spinner.run(`Retrieving data from ${onText}...`, async () => { // NOSONAR
        return await Promise.all(targets.map(async target => {

            let binding;
            if (on === 'k8s') {
                binding = { type: on, name: target };
            } else if (on === 'cf') {
                const [instance, key] = target.split(/:/);
                binding = { type: on, instance, key };
            } else {
                throwError();
            }

            const resolvedService = await resolveBinding(undefined, binding);
            resolvedService._target = target;
            delete resolvedService.credentials;
            resolvedService.binding.resolved = false;
            return resolvedService;
        }));
    });

    if (options.kind) {
        resolvedServices.forEach(service => service.kind = options.kind);
    } else {
        determineKinds(resolvedServices, LOG);
    }

    for (const resolvedService of resolvedServices) {
        if (serviceArg) {
            resolvedService.name = serviceArg;
        } else if (resolvedService.kind) {
            resolvedService.name = getRequiresNameFromKind(resolvedService.binding.instance, resolvedService.kind);
        }

        if (!resolvedService.name) {
            if (isJavaProject) {
                const { binding } = resolvedService;
                // Generate a custom service entry for Java projects w/o the need to specify a name manually
                resolvedService.name = `custom-service:${binding.instance || binding.secret}`
            } else {
                throw new Error(`Unknown CDS service name for service "${resolvedService._target}". Please specify as argument for "cds bind".`)
            }
        }

        const { kind, name, binding } = resolvedService;
        const kindText = kind && `with kind ${highlight(kind)}`;
        const nameText = !isJavaProject && highlight(name);

        logger.log(['Binding', nameText, 'to', platformText(binding), bindingText(binding, highlight), kindText].filter(t => t).join(' '));

        if (isJavaProject && !hasVcapLabel(binding) && !hasVcapLabel(env.requires[resolvedService.name]) && !(kind && hasVcapLabel(env.requires[kind]))) {
            resolvedService.vcap = { label: VCAP_LABEL_PLACEHOLDER };
            logger.log(`${info('INFO:')} Please add a "vcap.label" property to the binding for consumption in CAP Java projects`);
        }
    }

    // prepare for different providers
    const userCdsrcJsonStorageProvider = require('../lib/bind/userCdsrcJsonStorageProvider');

    await userCdsrcJsonStorageProvider.storeServices(resolvedServices, {
        ...options,
        logger
    });

    logger.log();
    logger.log(`${info('TIP:')} Run with cloud bindings: ${bold(runCmd(options, isJavaProject))}`);
}

async function cds_bind_exec(command) { // eslint-disable-lint
    const cds = require('@sap/cds/lib');
    const env = cds.env.for('cds', process.cwd());
    env._emulate_vcap_services();
    await require('../lib/bind/bindingResolver').applyTo({ env, output: 'info' });
    execAndExit(...command);
}

function hasVcapLabel(service) {
    return service && service.vcap && service.vcap.label && service.vcap.label != VCAP_LABEL_PLACEHOLDER;
}

function runCmd({ profile }, isJavaProject) {
    if (isJavaProject) {
        const p = profile === 'hybrid' ? '' : ` --profile ${profile}`;
        return `cds bind exec${p} mvn spring-boot:run`;
    } else {
        const p = profile === 'development' ? '' : ` --profile ${profile}`;
        return `cds watch${p}`;
    }
}

function setProfile(profile) {
    profile = parseProfile(profile);
    if (profile) process.env.CDS_ENV = profile;
}

function parseProfile(profile) {
    if (!profile) return 'hybrid';
    else if (profile === '-') return 'development';
    else return profile;
}
