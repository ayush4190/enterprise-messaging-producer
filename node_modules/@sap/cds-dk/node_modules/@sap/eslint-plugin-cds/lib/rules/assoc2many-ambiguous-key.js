module.exports = {
  meta: {
    docs: {
      description:
        "Ambiguous key with a `TO MANY` relationship since entries could appear multiple times with the same key.",
      category: "Model Validation",
      recommended: true,
      version: "1.0.1",
    },
    severity: "warn",
    type: "problem",
  },
  create(context) {
    return { all: check_assoc2many_ambiguous_key };

    function check_assoc2many_ambiguous_key() {
      let reports = [];
      let csnOdata;
      const m = context.cds.model;
      if (m && m.definitions) {
        csnOdata = context.cds.compile.for.odata(m);
        const csnOdataLinked = context.cds.linked(csnOdata);
        reports = associationCardinalityFlaw(csnOdataLinked, context);
      }
      if (reports.length > 0) {
        return reports;
      }
    }
  },
};

function associationCardinalityFlaw(csn, context) {
  const reports = [];
  processEntity(csn, (definition, sourceEntity, sourceAlias) => {
    let refCardinalityMult = false;
    let refPlainElement = false;
    processElement(
      csn,
      definition,
      sourceEntity,
      sourceAlias,
      () => {
        refCardinalityMult = false;
        refPlainElement = false;
      },
      (refEntity, refElement) => {
        if (refElement.type === "cds.Association" || refElement.type === "cds.Composition") {
          if (refElement.cardinality && refElement.cardinality.max === "*") {
            refCardinalityMult = true;
          }
        } else {
          refPlainElement = true;
        }
      },
      (column) => {
        if (
          definition.keys &&
          Object.keys(definition.keys).length === 1 &&
          Object.keys(definition.keys)[0] === "ID" &&
          refCardinalityMult &&
          refPlainElement
        ) {
          const keyName = Object.keys(definition.keys)[0];
          const key = definition.keys[keyName];
          const keyLoc = context.cds.getLocation(keyName, key, csn);
          const colName = column.as ? column.as : column.name;
          if (context.sourcecode.lines[column.$location.line - 1]) {
            const endCol = context.sourcecode.lines[column.$location.col - 1].length;
            const colLoc = {
              start: { line: column.$location.line, column: column.$location.col - 1 },
              end: { line: column.$location.line, column: endCol },
            };
            const message = `Ambiguous key in '${definition.name}'. Element '${colName}' leads to multiple entries so that key '${keyName}' is not unique.`;
            reports.push(
              {
                message,
                loc: keyLoc,
                file: key.$location.file,
              },
              {
                message,
                loc: colLoc,
                file: column.$location.file,
              }
            );
          }
        }
      }
    );
  });
  return reports;
}

function processEntity(csn, eachCallback) {
  Object.keys(csn.definitions).forEach((name) => {
    if (name.startsWith("localized.")) {
      return;
    }
    const definition = csn.definitions[name];
    if (
      definition.kind === "entity" &&
      definition.query &&
      definition.query.SELECT &&
      definition.query.SELECT.columns
    ) {
      let sourceEntity;
      const sourceAlias = [];
      if (definition.query.SELECT.from.ref) {
        // From
        sourceEntity = csn.definitions[definition.query.SELECT.from.ref.join("_")];
        sourceAlias.push({
          from: sourceEntity.name,
          as: definition.query.SELECT.from.as || definition.query.SELECT.from.ref.slice(-1)[0].split(".").pop(),
        });
      } else if (definition.query.SELECT.from.args && definition.query.SELECT.from.args[0].ref) {
        // Join
        sourceEntity = csn.definitions[definition.query.SELECT.from.args[0].ref.join("_")];
        definition.query.SELECT.from.args.forEach((arg) => {
          sourceAlias.push({
            from: arg.ref.join("_"),
            as: arg.as || arg.ref.slice(-1)[0].split(".").pop(),
          });
        });
      }
      if (!sourceEntity) {
        return;
      }
      eachCallback(definition, sourceEntity, sourceAlias);
    }
  });
}

function processElement(csn, definition, sourceEntity, sourceAlias, beforeCallback, eachCallback, afterCallback) {
  definition.query.SELECT.columns.forEach((column) => {
    if (column.ref && column.ref.length > 1) {
      let refEntity = sourceEntity;
      let refAlias = sourceAlias;
      beforeCallback();
      column.ref.forEach((ref) => {
        ref = ref.id || ref;
        // Alias
        const matchAlias = refAlias.find((alias) => {
          return alias.as === ref;
        });
        let refElement;
        if (matchAlias) {
          refEntity = csn.definitions[matchAlias.from];
        } else {
          refElement = refEntity.elements[ref];
          // Mixin
          if (!refElement) {
            refElement = definition.elements[ref];
            if (!refElement && definition.query.SELECT.mixin) {
              refElement = definition.query.SELECT.mixin[ref];
              if (!refElement && definition.query.SELECT.mixin[column.ref[0]]) {
                refElement = definition.query.SELECT.mixin[column.ref[0]]._target.elements[ref];
              }
            }
          }
          eachCallback(refEntity, refElement);
          if (refElement.type === "cds.Association" || refElement.type === "cds.Composition") {
            refEntity = csn.definitions[refElement.target];
          }
        }
        refAlias = [];
      });
      afterCallback(column);
    }
  });
}
